<!DOCTYPE html>
<html>
<head>
    <title>Δομές δεδομένων και αλγόριθμοι</title>
    <meta charset="UTF-8">
</head>
<body>

<h1 style = "color: MediumSeaGreen;">Δομές δεδομένων και αλγόριθμοι</h1>

<p><b>Στοίβα (stack),</b> ονομάζεται μια δομή δεδομένων το σύνολο των στοιχείων της οποίας είναι
    διατεταγμένο με τέτοιο τρόπο, ώστε τα στοιχεία που βρίσκονται στην κορυφή της στοίβας
    λαμβάνονται πρώτα, ενώ αυτά που βρίσκονται στο βάθος της στοίβας λαμβάνονται
    τελευταία. Η παραπάνω μέθοδος ονομάζεται Τελευταίο Μέσα, Πρώτο Έξω ή LIFO (=Last In
    First Out).</p>

<b>Οι κύριες λειτουργίες σε μια στοίβα</b>

<ol>
    <li>Η <b>ώθηση (push)</b> στοιχείου στην κορυφή της στοίβας. Στη διαδικασία της ώθησης
        ελέγχουμε αν η στοίβα είναι γεμάτη. Στην περίπτωση που προσπαθήσουμε να
        «προσθέσουμε» ένα στοιχείο σε μια ήδη γεμάτη στοίβα, έχουμε <b>υπερχείλιση
        (overflow)</b> της στοίβας.</li>
    <p></p>
    <li>Η <b>απώθηση (pop)</b> στοιχείου από τη στοίβα. Στη διαδικασία της απώθησης
        ελέγχουμε αν υπάρχει ένα τουλάχιστον στοιχείο στη στοίβα. Στην περίπτωση που
        προσπαθήσουμε να «αφαιρέσουμε» ένα στοιχείο από μία κενή στοίβα, έχουμε
        <b>υποχείλιση (underflow)</b> της στοίβας.</li>
</ol>

<b>Υλοποίηση στοίβας με χρήση μονοδιάστατου πίνακα</b>

<p>Χρησιμοποιούμε μια <b>βοηθητική μεταβλητή (top)</b>, που δείχνει το στοιχείο που
    τοποθετήθηκε τελευταίο στην κορυφή της στοίβας.</p>

<p>Η <b>ώθηση ενός νέου στοιχείου στη στοίβα</b> (εισαγωγή στοιχείου στον πίνακα) γίνεται
    πάντα στην κορυφή της. Συγκεκριμένα, η μεταβλητή top αυξάνεται κατά ένα: top←top+1 και
    στη συνέχεια γίνεται η ώθηση του στοιχείου.</p>

<p>• Η <b>απώθηση ενός στοιχείου από τη στοίβα</b> (εξαγωγή από τον πίνακα) γίνεται πάντα από
    την κορυφή της στοίβας. Συγκεκριμένα, εξάγεται το στοιχείο που δείχνει η μεταβλητή top και
    στη συνέχεια η μεταβλητή top μειώνεται κατά ένα: top← top-1</p>

<p><b>Ουρά (Queue)</b>, ονομάζεται μια δομή δεδομένων το σύνολο των στοιχείων της οποίας είναι
    διατεταγμένο με τέτοιο τρόπο, ώστε τα στοιχεία που τοποθετήθηκαν πρώτα στην ουρά να
    λαμβάνονται επίσης πρώτα. Η παραπάνω μέθοδος ονομάζεται Πρώτο Μέσα, Πρώτο Έξω ή
    FIFO (=First In First Out).</p>

<b>Οι κύριες λειτουργίες που εκτελούνται σε μια ουρά είναι δύο:</b>
<ol>
    <li>Η <b>εισαγωγή (enqueue)</b> στοιχείου στο πίσω άκρο της ουράς.</li>
    <p></p>
    <li>Η <b>εξαγωγή (dequeue)</b> στοιχείου από το εμπρός άκρο της ουράς</li>
</ol>

<b>Υλοποίηση ουράς με χρήση μονοδιάστατου πίνακα</b>

<p>→Χρησιμοποιούμε <b>δύο μεταβλητές</b>, την <b>front (ή εμπρός)</b> που δείχνει τη θέση του 1ου
    στοιχείου της ουράς και την <b>rear (ή πίσω)</b> που δείχνει τη θέση του τελευταίου στοιχείου.<b>Ως
    αρχικές τιμές των μεταβλητών rear και front θεωρούμε το μηδέν.</b></p>

<p>→Η <b>εισαγωγή ενός νέου στοιχείου</b> γίνεται από το πίσω άκρο της ουράς και η τιμή της
    μεταβλητής rear αλλάζει ως εξής:</p>

<p>rear← rear+1</p>

<p>Κατά την εισαγωγή, πρώτα αυξάνουμε τον δείκτη rear κατά ένα και μετά εισάγουμε το
    στοιχείο στον πίνακα.</p>

<p>→<b>Η εξαγωγή ενός στοιχείου</b> γίνεται από το εμπρός άκρο της ουράς και η τιμή της
    μεταβλητής front αλλάζει ως εξής:</p>

<p>front ←front +1</p>

<p>Κατά την εξαγωγή ενός στοιχείου, αυξάνεται ο δείκτης front κατά ένα (δείχνει στην επόμενη
    θέση του πίνακα) <b>χωρίς στην πραγματικότητα να γίνεται καμία παρέμβαση στα
    περιεχόμενα του πίνακα (χωρίς να διαγράφεται κάποιο στοιχείο).</b></p>

<b>Λίστες</b>

<p>Μία <b>(απλά) συνδεδεμένη λίστα (linked list)</b> είναι ένα <b>σύνολο κόμβων</b> διατεταγμένων
    <b>γραμμικά</b> (ο ένας μετά τον άλλο). Κάθε κόμβος περιέχει εκτός από τα δεδομένα του και έναν
    δείκτη που δείχνει προς τον επόμενο κόμβο. Ο δείκτης του τελευταίου κόμβου δε δείχνει σε
    κάποιον κόμβο (δείκτης στο κενό). Για να το δηλώσουμε αυτό λέμε ότι το πεδίο δείκτη του
    τελευταίου κόμβου έχει την τιμή NULL.</p>

<p>Για να προσπελάσουμε τους κόμβους της λίστας χρειάζεται να γνωρίζουμε τη διεύθυνση
    (θέση στη μνήμη) του πρώτου κόμβου της λίστας. Η διεύθυνση αυτή αποθηκεύεται σε μία
    ειδική μεταβλητή που την ονομάζουμε συνήθως <b>Κεφαλή (Head).</b></p>

<b>Κόμβος μιας λίστας</b>

<p>Η συνδεδεμένη λίστα αποτελείται από μία σειρά από κόμβους, που συνήθως βρίσκονται σε
    <b>απομακρυσμένες θέσεις μνήμης.</b> Κάθε κόμβος αποτελείται από <b>δύο κύρια τμήματα.</b> Το
    πρώτο τμήμα περιέχει τα <b>δεδομένα</b> και το δεύτερο τμήμα φιλοξενεί τη <b>διεύθυνση του
    επόμενου κόμβου</b> με τον οποίο συνδέεται ή όπως αλλιώς θα λέγαμε στη γλώσσα των
    δομών δεδομένων, το δεύτερο τμήμα περιέχει έναν <b>δείκτη (pointer) που δείχνει στον
    επόμενο κόμβο.</b></p>

<b>Δείκτης μιας λίστας</b>

<p>Ο δείκτης (pointer) είναι ένας ιδιαίτερος τύπος δεδομένων που προσφέρεται από τις
    περισσότερες σύγχρονες γλώσσες προγραμματισμού. Ο δείκτης δε λαμβάνει αριθμητικές
    τιμές όπως ακέραιες, πραγματικές κ.ά., αλλά οι τιμές του είναι διευθύνσεις στην κύρια μνήμη
    και χρησιμοποιείται ακριβώς για τη σύνδεση των διαφόρων στοιχείων μιας δομής, που είναι
    αποθηκευμένα σε μη συνεχόμενες θέσεις μνήμης.</p>

<p>
    Διαφορές Λίστας σε σχέση με τον Πίνακα -
    <span style="color: #2ECC71;">Πλεονεκτήματα</span>
    -
    <span style="color: #E74C3C;">Μειονεκτήματα</span>
</p>

<b>Διαφορές</b>
<ul>
    <li>O πίνακας θεωρείται μια δομή <b>τυχαίας προσπέλασης,</b> σε αντίθεση με μια λίστα που
        είναι στην ουσία μια <b>δομή ακολουθιακής ή σειριακής προσπέλασης.</b> Για να
        φτάσουμε, δηλαδή, σ’ έναν κόμβο μιας λίστας πρέπει να περάσουμε από όλους τους
        προηγούμενους ξεκινώντας από τον πρώτο.</li>
    <p></p>
    <li>O πίνακας έχει <b>σταθερό μέγεθος,</b> το οποίο δηλώνεται εξαρχής κατά την υλοποίηση.
        Αυτό γίνεται, διότι ο πίνακας είναι στατική δομή δεδομένων σε αντίθεση με τη λίστα
        που είναι <b>δυναμική δομή</b> και το μέγεθός της μπορεί να μεταβάλλεται καθώς
        εισέρχονται νέοι κόμβοι στη λίστα ή διαγράφονται κάποιοι άλλοι.</li>
    <p></p>
    <li>Οι κόμβοι της λίστας αποθηκεύονται σε <b>μη συνεχόμενες θέσεις μνήμης</b> σε
        αντιδιαστολή με τους πίνακες, όπου τα στοιχεία αποθηκεύονται σε <b>συνεχόμενες
        θέσεις μνήμης.</b></li>
</ul>

<p></p>

<b>Πλεονεκτήματα των λιστών(έναντι των πινάκων)</b>

<ul>
    <li>Το δυναμικό τους μέγεθος</li>
    <p></p>
    <li>Η ευκολία εισαγωγής και διαγραφής από οποιοδήποτε μέρος της λίστας</li>
    <p></p>
    <li>Η μη αναγκαιότητα δήλωσης του μεγέθους τους</li>
</ul>

<b>Μειονεκτήματα των λιστών(έναντι των πινάκων)</b>

<ul>
    <li><b>Η τυχαία πρόσβαση στη λίστα δεν επιτρέπεται.</b> Είναι αδύνατο να φτάσετε στον
        n-οστό κόμβο μιας απλά συνδεδεμένης λίστας χωρίς πρώτα να περάσετε από όλους
        τους κόμβους διαδοχικά μέχρι τον συγκεκριμένο κόμβο ξεκινώντας από τον πρώτο
        κόμβο. Εναλλακτικά, στην περίπτωση της διπλά συνδεδεμένης λίστας μπορείτε να
        ξεκινήσετε και από τον τελευταίο κόμβο. Επομένως, δεν μπορούμε να
        πραγματοποιήσουμε με αποτελεσματικό τρόπο δυαδική αναζήτηση σε συνδεδεμένες
        λίστες.</li>
    <p></p>
    <li><b>Οι συνδεδεμένες λίστες έχουν πολύ μεγαλύτερη επιβάρυνση από τους πίνακες,</b>
        αφού οι συνδεδεμένοι κόμβοι της λίστας είναι δυναμικά κατανεμημένοι (οι οποίοι είναι
        λιγότερο αποτελεσματικοί στη χρήση της μνήμης) και κάθε κόμβος στη λίστα πρέπει,
        επιπλέον, να αποθηκεύσει έναν πρόσθετο δείκτη που θα δείχνει στον επόμενο
        κόμβο. Στην περίπτωση των διπλά συνδεδεμένων λιστών χρειαζόμαστε επιπλέον
        έναν δεύτερο δείκτη που θα δείχνει στον προηγούμενο κόμβο.</li>
</ul>

<b>Βασικές πράξεις των συνδεδεμένων λιστών</b>
<ol>
    <li>Εισαγωγή κόμβου στη λίστα (εισαγωγή κόμβου στην αρχή, στο τέλος της λίστας ή
        ενδιάμεσα).</li>
    <p></p>
    <li>Διαγραφή κόμβου από τη λίστα (διαγραφή από την αρχή, το τέλος της λίστας ή
        ενδιάμεσα).</li>
    <p></p>
    <li>Έλεγχος για το αν η λίστα είναι κενή.</li>
    <p></p>
    <li>Αναζήτηση κόμβου για την εύρεση συγκεκριμένου στοιχείου.</li>
    <p></p>
    <li>Διάσχιση της λίστας και προσπέλαση των στοιχείων της (π.χ. εκτύπωση των
        δεδομένων που περιέχονται σε όλους τους κόμβους της λίστας).</li>
</ol>

<p></p>

<b>Δένδρα</b>

<p>Ένα δένδρο (tree) είναι μία δομή που αποτελείται από ένα <b>σύνολο κόμβων και ένα
    σύνολο ακμών</b> μεταξύ των κόμβων με βάση τους εξής κανόνες:</p>

<ul>
    <li>Υπάρχει ένας ξεχωριστός κόμβος που ονομάζεται ρίζα. Αυτός είναι ένας κόμβος χωρίς
        γονέα.</li>
    <p></p>
    <li>• Για κάθε κόμβο c, εκτός από τη ρίζα, υπάρχει μόνο μια ακμή που καταλήγει στον κόμβο
        αυτόν ξεκινώντας από κάποιον άλλον κόμβο p. Ο κόμβος p ονομάζεται γονέας του c και ο
        κόμβος c παιδί του p.</li>
    <p></p>
    <li>Για κάθε κόμβο υπάρχει μία μοναδική διαδρομή, δηλαδή, μια ακολουθία διαδοχικών ακμών,
        που ξεκινάει από τη ρίζα και τερματίζει σε αυτόν τον κόμβο.</li>
</ul>

<p><b>Δένδρο θεωρείται και το κενό δένδρο,</b> δηλαδή το δένδρο που δεν έχει ούτε κόμβους, ούτε
    ακμές.
    <b>Το κενό δένδρο είναι το μόνο δένδρο χωρίς ρίζα.</b></p>

<b>Υποδένδρο</b>
<p>Κάθε κόμβος ενός δένδρου μπορεί να θεωρηθεί ως ρίζα ενός υποδένδρου, δηλαδή ενός
    άλλου μικρότερου δένδρου, που ξεκινάει από τον κόμβο αυτόν.</p>

<b>Διατεταγμένο δένδρο</b>
<p>Αν για κάθε κόμβο υπάρχει μία γραμμική σχέση μεταξύ των παιδιών του κόμβου αυτού,
    αναφερόμαστε σε ένα διατεταγμένο δένδρο.</p>

<b>Πλεονεκτήματα δένδρων</b>
<p>Υπάρχουν 3 λόγοι για τους οποίους τα δένδρα είναι τόσο ισχυρά.</p>
<ul>
    <li>Ο πρώτος λόγος αναφέρεται στη <b>δυναμικότητα των δένδρων.</b> Είναι πολύ εύκολο να
        προσθέσετε, να αφαιρέσετε ή να αναζητήσετε ένα στοιχείο σε ένα δένδρο, όπως θα δούμε
        στη συνέχεια.</li>
    <p></p>
    <li>Ο δεύτερος βασικός λόγος είναι ότι η δομή των δένδρων μεταφέρει πληροφορίες.</li>
    <p></p>
    <li>Ο τρίτος λόγος είναι η αποτελεσματική οργάνωση και διαχείριση των δεδομένων.</li>
</ul>

<b>Δένδρο απόφασης</b>
<p>Τα δένδρα απόφασης είναι δένδρα στα οποία κάθε κόμβος αντιπροσωπεύει ένα
    χαρακτηριστικό(ιδιότητα), κάθε ακμή αντιπροσωπεύει μια απόφαση(κανόνα) και κάθε φύλλο
    αντιπροσωπεύει ένα αποτέλεσμα.</p>

<b>Δένδρο παιχνιδιού(Game tree)</b>

<p>Σε παιχνίδια όπως το σκάκι, η τρίλιζα, το τάβλι και πολλά άλλα, ο υπολογιστής χρησιμοποιεί
    ένα ειδικό δένδρο, που ονομάζεται δένδρο του παιχνιδιού (game tree), το οποίο
    μοντελοποιεί όλες τις πιθανές κινήσεις των παικτών για να νικήσει. Θα μπορούσε κάθε
    κόμβος στο δένδρο, που αντιπροσωπεύει μία συγκεκριμένη κατάσταση παιχνιδιού, να
    περιέχει πληροφορίες σχετικά με το ποιος παίκτης έχει τη μεγαλύτερη πιθανότητα να
    κερδίσει από οποιαδήποτε πιθανή κίνηση.</p>

<b>Δυαδικό δένδρο</b>
<p>Ένα δυαδικό δένδρο (binary tree) είναι ένα διατεταγμένο δένδρο, στο οποίο κάθε κόμβος έχει
    το <b>πολύ δύο παιδιά,</b> το αριστερό και το δεξί παιδί. Μπορούμε, συνεπώς, να μιλάμε για
    αριστερό και δεξιό υποδένδρο ενός κόμβου</p>

<b>Δυαδικό δένδρο αναζήτησης</b>

<p>Ένα δυαδικό δένδρο αναζήτησης (binary search tree) είναι ένα δυαδικό δένδρο, όπου για
    κάθε κόμβο u, όλοι οι κόμβοι του αριστερού υποδένδρου έχουν τιμές μικρότερες της τιμής
    του κόμβου u και όλοι οι κόμβοι του δεξιού υποδένδρου έχουν τιμές μεγαλύτερες (ή ίσες) της
    τιμής του κόμβου u.</p>

<b>Πλεονεκτήματα του δυαδικού δένδρου αναζήτησης</b>

<p>Το πλεονέκτημα βρίσκεται στο ίδιο το όνομα και συγκεκριμένα στη λέξη <b>«αναζήτηση».</b> Η
    αναζήτηση για μια συγκεκριμένη τιμή γίνεται <b>ταχύτερα χάρη στον τρόπο αποθήκευσης
    των τιμών.</b></p>

<p>Τα δυαδικά δένδρα αναζήτησης συνδυάζουν τα πλεονεκτήματα των λιστών, όσον αφορά τις
    <b>πράξεις της εισαγωγής και της διαγραφής,</b> αλλά και τα πλεονεκτήματα των
    ταξινομημένων πινάκων, όσον αφορά <b>την πράξη της αναζήτησης.</b></p>

<b>Γράφοι</b>

<p>Ένας <b>γράφος (graph)</b> είναι μία δομή που αποτελείται από ένα σύνολο κόμβων (ή σημείων ή
    κορυφών) και ένα σύνολο γραμμών (ή ακμών ή τόξων) που ενώνουν μερικούς ή όλους τους
    κόμβους. Ο γράφος αποτελεί την πιο <b>γενική δομή δεδομένων,</b> με την έννοια ότι όλες οι
    προηγούμενες δομές που παρουσιάστηκαν μπορούν να θεωρηθούν περιπτώσεις γράφων.</p>

<b>Κατευθυνόμενος και μη κατευθυνόμενος γράφος</b>

<p>Εάν όλες οι ακμές σε έναν γράφο έχουν κατεύθυνση, ο γράφος ονομάζεται <b>κατευθυνόμενος
    γράφος (directed graph).</b></p>
<p>Εάν όλες οι ακμές σε έναν γράφο δεν έχουν κατεύθυνση, ο γράφος ονομάζεται <b>μη
    κατευθυνόμενος γράφος (undirected graph).</b></p>

<p></p>




</body>
</html>